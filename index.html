<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Yolk of Truth</title>
  <link rel="icon" type="image/png" href="./assets/eggs/eggs-01.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <!-- Preload critical fonts for better mobile performance -->
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&family=Baskervville:wght@400&family=Inter:wght@400&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'" />
  <noscript><link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800&family=Baskervville:wght@400&family=Inter:wght@400&display=swap" rel="stylesheet" /></noscript>
  <link rel="stylesheet" href="./styles.css" />
  <script src="./fortune-data.js"></script>
  <script src="./app.js"></script>
</head>
<body>
  <div class="main-container">
    <header class="hero">
      <h1 class="hero-title">Yolk of Truth</h1>
      <p class="hero-sub">
        <span>Tap an egg</span>
        <span>•</span>
        <span>Watch it break</span>
        <span>•</span>
        <span>Discover your fortune</span>
      </p>
      <p class="hero-sub-mobile">Discover your fortune</p>
    </header>
    <main class="board" aria-label="Egg selection grid">
      <section class="egg-grid" role="list" id="eggGrid">
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-01.png" alt="Egg 1" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-02.png" alt="Egg 2" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-03.png" alt="Egg 3" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-04.png" alt="Egg 4" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-05.png" alt="Egg 5" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-06.png" alt="Egg 12" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-12.png" alt="Egg 7" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-09.png" alt="Egg 12" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-10.png" alt="Egg 10" /></div>
        <div class="egg-tile" role="listitem"><img class="egg-icon" src="./assets/eggs/eggs-11.png" alt="Egg 11" /></div>
      </section>
    </main>
  </div>


  <script>
  // On egg click, bounce then show fortune (no crack effect)
  (function(){
    const grid = document.getElementById('eggGrid');
    if(!grid) return;
    // Use the fortune data from fortune-data.js
    const fortunes = FORTUNE_DATA;
    grid.addEventListener('click', (e) => {
      const tile = e.target.closest('.egg-tile');
      if (!tile) return;
      const img = tile.querySelector('.egg-icon');
      if (img) {
        // force hover-like scaled state so egg looks active
        img.style.setProperty('--hover-transform', 'scale(1.28) rotate(-10deg) rotateY(18deg)');
        // Add subtle movement animation during the effect
        img.classList.add('animating');
        img.style.animation = 'egg-click-movement 800ms ease-out';
        setTimeout(() => { 
          img.classList.remove('animating'); 
          img.style.animation = 'none'; 
        }, 850);
      }

      // Create animation centered on the egg tile
      const rect = tile.getBoundingClientRect();
      const centerLeft = rect.left + rect.width / 2;
      const centerTop = rect.top + rect.height / 2;

      // Disable scroll during VFX sequence
      document.body.classList.add('no-scroll');

      // Add shake animation to the egg (more pronounced)
      img.style.animation = 'egg-shake-xy 800ms ease-out';
      setTimeout(() => {
        img.style.animation = 'none';
      }, 850);

      // Start directly with expanding circle rings + star particles
      // More Rings (increased from 3 to 5)
      for (let i = 0; i < 5; i++) {
        const circle = document.createElement('div');
        circle.className = 'circle';
        const ringSize = 80 + i * 25;
        circle.style.left = `${centerLeft - ringSize / 2}px`;
        circle.style.top = `${centerTop - ringSize / 2}px`;
        circle.style.width = circle.style.height = `${ringSize}px`;
        circle.style.animationDuration = `${0.8 + i * 0.15}s`;
        document.body.appendChild(circle);
        circle.addEventListener('animationend', () => circle.remove(), { once: true });
      }
      
      // More Stars (increased from 15 to 25)
      for (let i = 0; i < 25; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = `${centerLeft}px`;
        star.style.top = `${centerTop}px`;
        const angle = Math.random() * 2 * Math.PI;
        const distance = 80 + Math.random() * 80;
        const dx = Math.cos(angle) * distance + 'px';
        const dy = Math.sin(angle) * distance + 'px';
        star.style.setProperty('--dx', dx);
        star.style.setProperty('--dy', dy);
        document.body.appendChild(star);
        star.addEventListener('animationend', () => star.remove(), { once: true });
      }

      // Wait for the longest ring animation (~1.4s from now) before enabling scroll and showing overlay
      setTimeout(() => {
        document.body.classList.remove('no-scroll');
        
        // Create white radial overlay
        const radialOverlay = document.createElement('div');
        radialOverlay.className = 'radial-overlay';
        radialOverlay.style.left = `${centerLeft - 300}px`;
        radialOverlay.style.top = `${centerTop - 300}px`;
        document.body.appendChild(radialOverlay);
        
        // Show fortune overlay after radial animation starts
        setTimeout(() => {
          // Stop all animations when message appears
          document.querySelectorAll('.circle, .star').forEach(el => {
            el.style.animation = 'none';
            el.remove();
          });
          
          // Stop egg shake animation
          img.style.animation = 'none';
          
          const overlay = document.getElementById('fortuneOverlay');
          const fortuneText = document.getElementById('fortuneText');
          if (!overlay || !fortuneText) return;
          
          const selectedFortune = fortunes[Math.floor(Math.random() * fortunes.length)];
          fortuneText.textContent = selectedFortune.quote;
          
          // Update the fortune image
          const fortuneImage = document.querySelector('.dummy-egg-image');
          if (fortuneImage) {
            fortuneImage.src = selectedFortune.image;
            fortuneImage.alt = `Fortune ${selectedFortune.id}`;
          }
          
          // Position overlay to originate from clicked egg (desktop only)
          if (window.innerWidth > 640) {
            overlay.style.setProperty('--egg-x', `${centerLeft}px`);
            overlay.style.setProperty('--egg-y', `${centerTop}px`);
          }
          
          // Show overlay properly
          overlay.classList.remove('hidden', 'closing');
          overlay.classList.add('showing');
          
          // Reset animation state for new fortune card
          const card = document.querySelector('.fortune-card');
          if (card) {
            card.classList.remove('animation-complete');
          }
          
          // Initialize hover effect for the fortune card
          setTimeout(() => {
            initFortuneCardHover();
            // Mark animation as complete after initial animation finishes
            setTimeout(() => {
              const card = document.querySelector('.fortune-card');
              if (card) {
                card.classList.add('animation-complete');
              }
            }, 800); // Wait for the card-3d-spin-in animation to complete
          }, 100);
          
          console.log('Overlay should be visible now', overlay);
        }, 200);
        
        // Remove radial overlay after animation
        setTimeout(() => {
          radialOverlay.remove();
        }, 2000);
      }, 1400);
    });
  })();
  </script>

  <!-- Fortune overlay -->
  <div id="fortuneOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-labelledby="fortuneText">
    <div class="modal">
      <div class="fortune-card">
        <div class="fortune-image">
          <div class="fortune-gradient"></div>
          <div class="fortune-sparkles">
            <div class="sparkle sparkle-1"></div>
            <div class="sparkle sparkle-2"></div>
            <div class="sparkle sparkle-3"></div>
            <div class="sparkle sparkle-4"></div>
            <div class="sparkle sparkle-5"></div>
          </div>
          <!-- Dummy image for testing -->
          <img src="./assets/eggs/eggs-01.png" alt="Fortune Egg" class="dummy-egg-image" />
        </div>
        <div class="fortune-message">
          <p id="fortuneText">Your fortune awaits! This is a test message to see if the card is visible.</p>
        </div>
      </div>
      <div class="card-actions">
        <button id="shareFortune" class="action-btn">Share</button>
        <button id="tryAgain" class="action-btn" data-text="Try Again">Try Again</button>
      </div>
    </div>
  </div>

  <script>
    (function(){
      const overlay = document.getElementById('fortuneOverlay');
      const shareBtn = document.getElementById('shareFortune');
      const tryAgainBtn = document.getElementById('tryAgain');
      
      function resetAllEggs() {
        document.querySelectorAll('.egg-icon').forEach((el) => {
          // Clear animations
          el.style.animation = 'none';
          // Reset click-related CSS variables
          el.style.setProperty('--click-tilt-x', '0px');
          el.style.setProperty('--click-tilt-y', '0px');
          el.style.setProperty('--click-tilt-rot', '0deg');
          el.style.setProperty('--shake-x', '0px');
          el.style.setProperty('--shake-y', '0px');
          // Remove any inline hover-transform so stylesheet controls hover again
          el.style.removeProperty('--hover-transform');
          el.classList.remove('animating');
        });
      }
      
      function hide(){
        console.log('Hide function called');
        if (!overlay) {
          console.log('No overlay found');
          return;
        }
        
        // Clear any inline styles that might prevent hiding
        overlay.style.display = '';
        overlay.style.opacity = '';
        overlay.style.pointerEvents = '';
        
        const modal = overlay.querySelector('.modal');
        // Reset modal transform for next time
        if (modal) {
          modal.style.transform = '';
          modal.style.transition = '';
          modal.style.opacity = '';
        }
        
        overlay.classList.remove('showing');
        overlay.classList.add('closing');
        setTimeout(()=>{ 
          overlay.classList.add('hidden'); 
          overlay.classList.remove('closing');
          // After closing, reset all eggs to default state
          resetAllEggs();
          console.log('Modal closed');
        }, 320);
      }
      
      // Add keyboard escape handler
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay && !overlay.classList.contains('hidden')) {
          console.log('Escape key pressed');
          hide();
        }
      });
      
      function shareFortune() {
        const fortuneText = document.getElementById('fortuneText');
        const text = fortuneText?.textContent || '';
        
        if (navigator.share) {
          navigator.share({
            title: 'My Fortune',
            text: text,
            url: window.location.href
          });
        } else {
          // Fallback: copy to clipboard
          navigator.clipboard.writeText(text).then(() => {
            alert('Fortune copied to clipboard!');
          });
        }
      }
      
      function tryAgain() {
        console.log('Try Again clicked');
        hide();
      }
      
      function closeModal() {
        console.log('Closing modal');
        hide();
      }
      
      shareBtn?.addEventListener('click', shareFortune);
      tryAgainBtn?.addEventListener('click', tryAgain);
      
      // Close modal when clicking anywhere on the overlay
      overlay?.addEventListener('click', (e)=>{ 
        console.log('Overlay clicked', e.target);
        closeModal();
      });
      
      // Prevent card clicks from closing the modal
      const fortuneCard = overlay?.querySelector('.fortune-card');
      fortuneCard?.addEventListener('click', (e) => {
        console.log('Card clicked - preventing close');
        e.stopPropagation();
      });
    })();
  </script>

  <script>
  // Mobile swipe carousel: infinite loop with shuffle, one-step swipe, haptics, and rotate effect
  (function(){
    const grid = document.getElementById('eggGrid');
    if (!grid) return;

    const isMobile = () => window.matchMedia('(max-width: 640px)').matches;
    let initialized = false;

    function shuffleNoAdjDup(nodes){
      const arr = nodes.slice();
      // Fisher-Yates with retry to avoid adjacent equal src
      function hasAdjDup(a){
        for (let i=1;i<a.length;i++) {
          const prev = a[i-1].querySelector('img')?.getAttribute('src');
          const cur = a[i].querySelector('img')?.getAttribute('src');
          if (prev === cur) return true;
        }
        return false;
      }
      let attempts = 0;
      do {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        attempts++;
      } while (hasAdjDup(arr) && attempts < 20);
      // Final pass: if still adj dup, swap offending elements
      for (let i=1;i<arr.length;i++){
        const a = arr[i-1].querySelector('img')?.getAttribute('src');
        const b = arr[i].querySelector('img')?.getAttribute('src');
        if (a === b) {
          const k = (i+1) % arr.length;
          [arr[i], arr[k]] = [arr[k], arr[i]];
        }
      }
      return arr;
    }

    function initInfiniteCarousel(){
      if (initialized || !isMobile()) return;
      initialized = true;

      // Take originals and shuffle to avoid adjacent duplicates
      const originals = Array.from(grid.children);
      const shuffled = shuffleNoAdjDup(originals);
      // Rebuild grid with shuffled originals only once
      grid.innerHTML = '';
      shuffled.forEach(n => grid.appendChild(n));

      const originalCount = shuffled.length;
      if (originalCount === 0) return;

      // Clone one full set on both sides for seamless looping
      const headFrag = document.createDocumentFragment();
      const tailFrag = document.createDocumentFragment();
      shuffled.forEach(node => {
        const c = node.cloneNode(true); c.setAttribute('data-clone', 'true'); headFrag.appendChild(c);
      });
      shuffled.forEach(node => {
        const c = node.cloneNode(true); c.setAttribute('data-clone', 'true'); tailFrag.appendChild(c);
      });
      grid.insertBefore(headFrag, grid.firstChild);
      grid.appendChild(tailFrag);

      let tiles = Array.from(grid.children);
      let index = originalCount; // start at first original after head clones

      function setFocusByIndex(i){
        tiles.forEach((t, idx) => t.classList.toggle('is-focused', idx === i));
      }

      function rotateEggDuringSwipe(icon, direction){
        if (!icon) return;
        // Add class to disable transitions temporarily
        icon.classList.add('swipe-rotating');
        // Set rotation based on swipe direction - rotate OUT of center
        const angle = direction > 0 ? '-12deg' : '12deg';
        icon.style.setProperty('--swipe-rot', angle);
      }

      function centerEgg(icon){
        if (!icon) return;
        // Return to center (0deg) smoothly
        icon.style.setProperty('--swipe-rot', '0deg');
        // Remove class after transition
        setTimeout(()=>{ 
          icon.classList.remove('swipe-rotating');
        }, 300);
      }

      function scrollToIndex(i, behavior){
        tiles[i]?.scrollIntoView({ behavior: behavior || 'smooth', inline: 'center', block: 'nearest' });
        setFocusByIndex(i);
        // Center the newly focused egg
        const newIcon = tiles[i]?.querySelector('.egg-icon');
        centerEgg(newIcon);
      }

      // Jump to the starting position without animation
      scrollToIndex(index, 'auto');

      // Debounced scroll-end detection keeps centering and handles loop jumps
      let scrollTimer = null;
      grid.addEventListener('scroll', () => {
        if (scrollTimer) clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          const centerX = grid.scrollLeft + grid.clientWidth / 2;
          let closestIdx = index;
          let closestDist = Infinity;
          tiles.forEach((tile, i) => {
            const rect = tile.getBoundingClientRect();
            const gridRect = grid.getBoundingClientRect();
            const tileCenter = rect.left - gridRect.left + rect.width / 2 + grid.scrollLeft;
            const dist = Math.abs(tileCenter - centerX);
            if (dist < closestDist) { closestDist = dist; closestIdx = i; }
          });
          index = closestIdx;

          if (index < originalCount) {
            index += originalCount;
            scrollToIndex(index, 'auto');
          } else if (index >= originalCount * 2) {
            index -= originalCount;
            scrollToIndex(index, 'auto');
          } else {
            setFocusByIndex(index);
          }
        }, 80);
      }, { passive: true });

      // One-step swipe with haptic feedback
      let startX = 0, startY = 0, tracking = false;
      const threshold = 24;
      function haptic(){
        // Try vibration first
        if (navigator.vibrate) {
          navigator.vibrate(10);
        } else if (window.navigator?.vibrate) {
          window.navigator.vibrate(10);
        } else {
          // Fallback: visual feedback for desktop testing
          const currentTile = tiles[index];
          if (currentTile) {
            currentTile.style.transform = 'scale(0.95)';
            setTimeout(() => currentTile.style.transform = '', 100);
          }
        }
      }
      grid.addEventListener('touchstart', (e)=>{
        if (!e.touches || !e.touches[0]) return;
        tracking = true;
        startX = e.touches[0].clientX; startY = e.touches[0].clientY;
      }, { passive: true });
      grid.addEventListener('touchmove', (e)=>{
        if (!tracking || !e.touches || !e.touches[0]) return;
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
        if (Math.abs(dx) > Math.abs(dy)) {
          const dir = dx > 0 ? -1 : 1; // step one card
          // Rotate current egg during swipe
          const currentIcon = tiles[index]?.querySelector('.egg-icon');
          rotateEggDuringSwipe(currentIcon, dir);
          
          index = Math.min(Math.max(index + dir, 0), tiles.length - 1);
          scrollToIndex(index, 'smooth');
          haptic();
          startX = e.touches[0].clientX; startY = e.touches[0].clientY;
        }
      }, { passive: true });
      grid.addEventListener('touchend', ()=>{ tracking = false; });

      // Tap on centered tile to open fortune
      grid.addEventListener('touchend', (e)=>{
        const focused = tiles[index];
        if (!focused) return;
        const touchedTile = e.target.closest('.egg-tile');
        if (touchedTile === focused) focused.click();
      });
    }

    if (isMobile()) initInfiniteCarousel();
    window.addEventListener('resize', () => { if (isMobile()) initInfiniteCarousel(); });
  })();

  // Fortune card hover effect with enhanced 3D tilt
  function initFortuneCardHover() {
    const card = document.querySelector('.fortune-card');
    console.log('initFortuneCardHover called, card found:', !!card);
    
    if (!card) {
      console.log('No fortune card found, aborting hover initialization');
      return;
    }

    console.log('Setting up hover effect for fortune card');

    // Remove any existing event listeners by cloning the element
    const newCard = card.cloneNode(true);
    card.parentNode.replaceChild(newCard, card);

    newCard.addEventListener('mousemove', (e) => {
      console.log('Mouse move detected on fortune card');
      const rect = newCard.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;

      // Calculate rotation with more pronounced 3D tilt effect
      // Increased rotation range for more dramatic effect
      const rotateX = ((y - centerY) / centerY) * 15; // Increased from 8 to 15
      const rotateY = ((x - centerX) / centerX) * -15; // Increased from 8 to 15
      
      // Add subtle scale and translate for lift effect
      const scale = 1.02; // More subtle scale
      const translateZ = 10; // Reduced Z translation for subtlety

      newCard.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale}) translateZ(${translateZ}px)`;
      newCard.style.setProperty('--x', `${(x / rect.width) * 100}%`);
      newCard.style.setProperty('--y', `${(y / rect.height) * 100}%`);

      newCard.classList.add('hovering');
    });

    newCard.addEventListener('mouseleave', () => {
      console.log('Mouse leave detected on fortune card');
      // Reset to original state without triggering the animation
      newCard.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg) scale(1) translateZ(0px)';
      newCard.style.setProperty('--x', '50%');
      newCard.style.setProperty('--y', '50%');
      newCard.classList.remove('hovering');
    });
    
    console.log('Hover effect initialized successfully');
  }
  </script>
</body>
</html>

